<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bennet Leff</title>
    <atom:link href="https://bennetleff.github.io/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>https://bennetleff.github.io</link>
    <description>Blog</description>
    <pubDate>Sun, 30 Sep 2018 19:00:00 -0500</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Ample</title>
      <link>https://bennetleff.github.io/articles/Removing-Ref-Counting/</link>
      <pubDate>Sun, 30 Sep 2018 19:00:00 -0500</pubDate>
      <guid isPermaLink="true">https://bennetleff.github.io/articles/Removing-Ref-Counting/</guid>
      <author></author>
      <description>&lt;p&gt;I’ve been reading about effective usage of modern C++ features and found many arguments against Reference Counting which is used in the standard’s &lt;code&gt;std::shared_ptr&lt;/code&gt; class. While following the JUCE Framework tutorials, I implemented a reference counted wrapper over an &lt;code&gt;AudioSampleBuffer&lt;/code&gt;. The tutorial suggests implementing the wrapper to alleviate multithreading issues. Unfortunately, this gets used straight in the audio player callback function or the “hot-path,” so to speak. Typically in an audio processing application, a function pointer to a callback is given to to the audio “host.” In PortAudio, there’s a callback the programmer must define that handles all audio data. It’s signature is given below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int patestCallback( const void *inputBuffer, void *outputBuffer,
                       unsigned long framesPerBuffer,
                       const PaStreamCallbackTimeInfo* timeInfo,
                       PaStreamCallbackFlags statusFlags,
                       void *userData )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In JUCE, this can be done less explicitly, within an AudioSource class method called &lt;code&gt;getNextAudioBlock&lt;/code&gt;. It’s important to keep the &lt;code&gt;getNextAudioBlock&lt;/code&gt; method as lightweight as possible to allow room for more interesting audio processing like spectral analysis, time stretching, or any number of effects. However, in the JUCE multithreading tutorial, it seems that Reference Counted &lt;code&gt;AudioSampleBuffer&lt;/code&gt;s are used without necessity. By using a &lt;code&gt;std::unique_ptr&lt;/code&gt;, we can actually handle ownership just fine. Frankly, I feel like I’m missing something but after some testing, I’ve been unable to convince myself that there’s any shared ownership necessary. Using move semantics we can be more explicit and reduce overhead. The updated &lt;code&gt;getNextAudioBlock&lt;/code&gt; follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct AudioSampleBuffer            // This struct is used in place of our RefCountedBuffer class.
{
    std::unique_ptr&amp;lt;AudioSampleBuffer&amp;gt; buffer_;
    uint32_t position_ = 0;
};

void SampleSource::getNextAudioBlock(const AudioSourceChannelInfo&amp;amp; buffer_to_fill)
{
    if (!is_playing())
    {
        buffer_to_fill.clearActiveBufferRegion();
        return;
    }

    /*
     * Once we know we&amp;#39;re actually playing audio we can proceed with loading and playing data.
     */
    if (current_buffer_.buffer_ == nullptr)
    {
        buffer_to_fill.clearActiveBufferRegion();
        return;
    }


    int32_t position = current_buffer_.position_;

    int32_t num_in_channels = current_buffer_.buffer_-&amp;gt;getNumChannels();
    int32_t num_out_channels = buffer_to_fill.buffer-&amp;gt;getNumChannels();

    int32_t out_samples_remaining = buffer_to_fill.numSamples;
    int32_t out_samples_offset = 0;

    while (out_samples_remaining &amp;gt; 0)
    {
        int32_t buffer_samples_remaining = current_buffer_.buffer_-&amp;gt;getNumSamples() - position_;
        int32_t samples_this_iter = jmin(out_samples_remaining, buffer_samples_remaining);

        for (int32_t channel = 0; channel &amp;lt; num_out_channels; ++channel)
        {
            buffer_to_fill.buffer-&amp;gt;copyFrom(channel,
                buffer_to_fill.startSample + out_samples_offset,
                *(current_buffer_.buffer_.get()),                 // unique_ptr dereferenced here to be copied into the output
                channel % num_in_channels,
                position_,
                samples_this_iter);
        }

        /*
         *    These operations are a bit like moving an audio &amp;quot;scrubber&amp;quot;. 
         *  Each step we move our needle, the position, along a bit further.
         *  This lets us keep track of where we are in the audio so that JUCE 
         *  can call getNextAudioBlock over and over while processing audio, and 
         *  &amp;quot;scrubbing&amp;quot; along.
         */
        out_samples_remaining -= samples_this_iter;
        out_samples_offset += samples_this_iter;
        set_position(position_ + samples_this_iter); 

        /*
         * If we get to the end of the sample buffer, we can stop playing.
         */
        if (position_ == current_buffer_.buffer_-&amp;gt;getNumSamples())
        {
            stop();
            buffer_to_fill.clearActiveBufferRegion();
            return;
        }
    }

    current_buffer_.position_ = position;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I plan to follow up with some benchmarks and more testing to ensure this is the right way to go. However, I’m almost certain this can’t be slower. So at the very least, it’s simpler to read.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ample</title>
      <link>https://bennetleff.github.io/articles/ample-article/</link>
      <pubDate>Sat, 29 Sep 2018 19:00:00 -0500</pubDate>
      <guid isPermaLink="true">https://bennetleff.github.io/articles/ample-article/</guid>
      <author></author>
      <description>&lt;p&gt;The Ample Sampler is a digtal drum machine, sampler, sequencer, and sound mangler.
It is not too dissimilar from the Elektron Octatrack. However, Ample makes an effort
to provide extensibility and ease of use in a cheaper package. Ultimately, the Ample should
be cheaper, easier to use, and more powerful than its predecessors.&lt;/p&gt;
&lt;p&gt;This blog will mostly act as a dev blog for the Ample but may include some detours.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>