<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Ample - Bennet Leff
    </title>
    <link rel="alternate" href="https://bennetleff.github.io/feed.xml" type="application/rss+xml" title="Blog">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Ample</h1>
        <p class="author">Written by <span class="author">Bennet Leff</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>I’ve been reading about effective usage of modern C++ features and found many arguments against Reference Counting which is used in the standard’s <code>std::shared_ptr</code> class. While following the <span class="caps">JUCE</span> Framework tutorials, I implemented a reference counted wrapper over an <code>AudioSampleBuffer</code>. The tutorial suggests implementing the wrapper to alleviate multithreading issues. Unfortunately, this gets used straight in the audio player callback function or the “hot-path,” so to speak. Typically in an audio processing application, a function pointer to a callback is given to to the audio “host.” In PortAudio, there’s a callback the programmer must define that handles all audio data. It’s signature is given&nbsp;below:</p>
<pre><code>int patestCallback( const void *inputBuffer, void *outputBuffer,
                       unsigned long framesPerBuffer,
                       const PaStreamCallbackTimeInfo* timeInfo,
                       PaStreamCallbackFlags statusFlags,
                       void *userData )
</code></pre><p>In <span class="caps">JUCE</span>, this can be done less explicitly, within an AudioSource class method called <code>getNextAudioBlock</code>. It’s important to keep the <code>getNextAudioBlock</code> method as lightweight as possible to allow room for more interesting audio processing like spectral analysis, time stretching, or any number of effects. However, in the <span class="caps">JUCE</span> multithreading tutorial, it seems that Reference Counted <code>AudioSampleBuffer</code>s are used without necessity. By using a <code>std::unique_ptr</code>, we can actually handle ownership just fine. Frankly, I feel like I’m missing something but after some testing, I’ve been unable to convince myself that there’s any shared ownership necessary. Using move semantics we can be more explicit and reduce overhead. The updated <code>getNextAudioBlock</code> follows:</p>
<pre><code>struct AudioSampleBuffer            // This struct is used in place of our RefCountedBuffer class.
{
    std::unique_ptr&lt;AudioSampleBuffer&gt; buffer_;
    uint32_t position_ = 0;
};

void SampleSource::getNextAudioBlock(const AudioSourceChannelInfo&amp; buffer_to_fill)
{
    if (!is_playing())
    {
        buffer_to_fill.clearActiveBufferRegion();
        return;
    }

    /*
     * Once we know we&#39;re actually playing audio we can proceed with loading and playing data.
     */
    if (current_buffer_.buffer_ == nullptr)
    {
        buffer_to_fill.clearActiveBufferRegion();
        return;
    }


    int32_t position = current_buffer_.position_;

    int32_t num_in_channels = current_buffer_.buffer_-&gt;getNumChannels();
    int32_t num_out_channels = buffer_to_fill.buffer-&gt;getNumChannels();

    int32_t out_samples_remaining = buffer_to_fill.numSamples;
    int32_t out_samples_offset = 0;

    while (out_samples_remaining &gt; 0)
    {
        int32_t buffer_samples_remaining = current_buffer_.buffer_-&gt;getNumSamples() - position_;
        int32_t samples_this_iter = jmin(out_samples_remaining, buffer_samples_remaining);

        for (int32_t channel = 0; channel &lt; num_out_channels; ++channel)
        {
            buffer_to_fill.buffer-&gt;copyFrom(channel,
                buffer_to_fill.startSample + out_samples_offset,
                *(current_buffer_.buffer_.get()),                 // unique_ptr dereferenced here to be copied into the output
                channel % num_in_channels,
                position_,
                samples_this_iter);
        }

        /*
         *    These operations are a bit like moving an audio &quot;scrubber&quot;. 
         *  Each step we move our needle, the position, along a bit further.
         *  This lets us keep track of where we are in the audio so that JUCE 
         *  can call getNextAudioBlock over and over while processing audio, and 
         *  &quot;scrubbing&quot; along.
         */
        out_samples_remaining -= samples_this_iter;
        out_samples_offset += samples_this_iter;
        set_position(position_ + samples_this_iter); 

        /*
         * If we get to the end of the sample buffer, we can stop playing.
         */
        if (position_ == current_buffer_.buffer_-&gt;getNumSamples())
        {
            stop();
            buffer_to_fill.clearActiveBufferRegion();
            return;
        }
    }

    current_buffer_.position_ = position;
}
</code></pre><p>I plan to follow up with some benchmarks and more testing to ensure this is the right way to go. However, I’m almost certain this can’t be slower. So at the very least, it’s simpler to&nbsp;read.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">&laquo; Full blog</a></div>
        <section class="copy">
          <p>&copy; 2018 Bennet Leff &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>